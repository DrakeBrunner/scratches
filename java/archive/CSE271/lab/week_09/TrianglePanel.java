/**
 * A graphics program to generate the well known
 * "Sierpinski Triangle". This is created by first defining three
 * vertices, and an initial random point. Subsequent points are
 * generated by repeatedly moving halfway from the last point to one
 * of the three randomly selected vertices.
 * 
 * @see http://en.wikipedia.org/wiki/Sierpinski_triangle
 * @author Norm Krumpe
 * @version 1.0
 */

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;

import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;

public class TrianglePanel extends JPanel {

	private static final int MANY = 1000;

	private Point[] vertices;
	private ArrayList<Point> randomPoints;
	private JButton btnClear, btnOne, btnMany;
	private JLabel lblCount;

	/**
	 * Constructs a TrianglePanel object. The panel is interactive
	 * (responds to mouse clicks), and has 3 buttons to draw and clear
	 * points, along with a label to count how many random points have
	 * been generated.
	 */
	public TrianglePanel() {
		super();

		// Instantiate the collections of points:
		randomPoints = new ArrayList<Point>();
		vertices = new Point[3];

		this.setPreferredSize(new Dimension(400, 400));
		this.setBackground(Color.WHITE);	// set color
		this.setLayout(null); // null lets me manually place components

		// Set up the buttons
		btnClear = new JButton("clear");
		int buttonHeight = btnClear.getPreferredSize().height;
		btnClear.setBounds(0, 0, 150, buttonHeight);
		btnOne = new JButton("one point");
		btnOne.setBounds(0, buttonHeight, 150, buttonHeight);
		btnOne.setEnabled(false);
		btnMany = new JButton("many points");
		btnMany.setBounds(0, 2 * buttonHeight, 150, buttonHeight);
		btnMany.setEnabled(false);
		this.add(btnClear);
		this.add(btnOne);
		this.add(btnMany);
		// Add a listener to all three buttons:
		this.addMouseListener(new MouseClickResponder());
		
		// Need to register a ButtonResponder
		ButtonResponder br = new ButtonResponder();
		btnClear.addActionListener(br);
		btnOne.addActionListener(br);
		btnMany.addActionListener(br);

		// Set up a label to count the points:
		lblCount = new JLabel("0 points");
		lblCount.setBounds(0, 3 * buttonHeight, 150, buttonHeight);
		lblCount.setHorizontalAlignment(JLabel.CENTER);
		lblCount.setBorder(BorderFactory.createLineBorder(Color.BLACK));
		lblCount.setForeground(Color.RED);
		this.add(lblCount);
	} // end constructor

	/**
	 * Draws all the points in both collections. The vertices will be
	 * drawn in blue, and the random points will be drawn in red.
	 */
	@Override
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		// Draw each of the 3 vertices in blue,
		// but don't try to draw something if
		// it is still null.
		g.setColor(new Color(0, 0, 255));
		for (Point p : vertices) {
			if (p != null) {
				g.fillOval(p.x, p.y, 10, 10);
			}
		}
		
		// Draw each of the random points in red
		g.setColor(new Color(255, 0, 0));
		for (Point p : randomPoints) {
			if (p != null) {
				g.fillOval(p.x, p.y, 4, 4);
			}
		}
	}

	/**
	 * Generates the next random point to be drawn.
	 */
	private void nextRandomPoint() {
		// The first random point is created differently...
		// it's just a random location on the screen:
		if (randomPoints.size() == 0) {
			int x, y;
			x = (int) (getWidth() * Math.random());
			y = (int) (getHeight() * Math.random());
			randomPoints.add(new Point(x, y));
		}

		// For all other points, randomly select a vertex,
		// and then compute the midpoint between that vertex
		// and the last drawn point:
		else {
			int whichVertex = (int)(Math.random() * 3);
			Point lastPoint = randomPoints.get(randomPoints.size() - 1);
			int midX = (int) ((lastPoint.getX() + vertices[whichVertex].getX()) / 2);
			int midY = (int) ((lastPoint.getY() + vertices[whichVertex].getY()) / 2);
			
			Point toAdd = new Point(midX, midY);
			randomPoints.add(toAdd);
		}
		lblCount.setText(randomPoints.size() + " Points");

	}

	/**
	 * Deletes all vertices and all random points. Since this method
	 * changes the points, it's necessary to then update the drawing to
	 * show that change.
	 */
	public void clearPoints() {
		// Clear vertices
		vertices[0] = null;
		vertices[1] = null;
		vertices[2] = null;
		
		// Clear randomPoints
		randomPoints.clear();
		lblCount.setText(randomPoints.size() + " Points");

        // Disable the "one" and "many" buttons
        btnOne.setEnabled(false);
        btnMany.setEnabled(false);
	}

	/**
	 * This is an inner-class. Its purpose is to define behaviors for
	 * mouse events, such as clicks. The MouseListener interface has 5
	 * methods that must be overridden, but the only one we care about
	 * in this application is the click. The others need to be there,
	 * but can be left with empty implementations.
	 * 
	 */
	public class MouseClickResponder implements MouseListener {

		@Override
		public void mouseClicked(MouseEvent e) {

			// To check if the click is recognized
			// System.out.println("CLICKED!");
			
			if (vertices[0] == null)
				vertices[0] = new Point(e.getX(), e.getY());
			else if (vertices[1] == null)
				vertices[1] = new Point(e.getX(), e.getY());
			else if (vertices[2] == null) {
				vertices[2] = new Point(e.getX(), e.getY());
				
				// This means that all the vertices are not null
				btnOne.setEnabled(true);
				btnMany.setEnabled(true);
			}
			
			// Because paintComponent is called only under certain situations
			repaint();
		}

		@Override
		public void mouseEntered(MouseEvent arg0) {
			// TODO Auto-generated method stub

		}

		@Override
		public void mouseExited(MouseEvent arg0) {
			// TODO Auto-generated method stub

		}

		@Override
		public void mousePressed(MouseEvent arg0) {
			// TODO Auto-generated method stub

		}

		@Override
		public void mouseReleased(MouseEvent arg0) {
			// TODO Auto-generated method stub
		}
		
	} // End MouseClickResponder class
	
	public class ButtonResponder implements ActionListener {

		@Override
		public void actionPerformed(ActionEvent e) {
			// To check if the button click is recognized
			// System.out.println("BUTTON PRESSED!");
			if (e.getSource() == btnClear)
				clearPoints();
			else if (e.getSource() == btnOne)
				nextRandomPoint();
			else if (e.getSource() == btnMany) {
				for (int i = 0; i < MANY; i++) {
					nextRandomPoint();
					repaint();
				}
			}
			
			repaint();
		}
	}

	/**
	 * Creates a frame and adds a TrianglePanel to it:
	 */
	public static void main(String[] args) {
		JFrame frame = new JFrame("Triangle");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.add(new TrianglePanel());
		frame.pack();
		frame.setLocationRelativeTo(null);
		frame.setVisible(true);
	}

}
